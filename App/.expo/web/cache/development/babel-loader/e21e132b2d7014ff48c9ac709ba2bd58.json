{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport pathToRegexp from 'path-to-regexp';\nimport NavigationActions from \"../NavigationActions\";\n\nvar queryString = require('query-string');\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n\n  for (var key in obj) {\n    return false;\n  }\n\n  return true;\n}\n\nexport var urlToPathAndParams = function urlToPathAndParams(url, uriPrefix) {\n  var searchMatch = url.match(/^(.*)\\?(.*)$/);\n  var params = searchMatch ? queryString.parse(searchMatch[2]) : {};\n  var urlWithoutSearch = searchMatch ? searchMatch[1] : url;\n  var delimiter = uriPrefix || '://';\n  var path = urlWithoutSearch.split(delimiter)[1];\n\n  if (path === undefined) {\n    path = urlWithoutSearch;\n  }\n\n  if (path === '/') {\n    path = '';\n  }\n\n  if (path[path.length - 1] === '/') {\n    path = path.slice(0, -1);\n  }\n\n  return {\n    path: path,\n    params: params\n  };\n};\nexport var createPathParser = function createPathParser(childRouters, routeConfigs) {\n  var pathConfigs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var initialRouteName = arguments.length > 3 ? arguments[3] : undefined;\n  var initialRouteParams = arguments.length > 4 ? arguments[4] : undefined;\n  var pathsByRouteNames = {};\n  var paths = [];\n  Object.keys(childRouters).forEach(function (routeName) {\n    var pathPattern = pathConfigs[routeName] || routeConfigs[routeName].path;\n    var matchExact = !!pathPattern && !childRouters[routeName];\n\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n\n    var keys = [];\n    var re, toPath, priority;\n\n    if (typeof pathPattern === 'string') {\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else if (pathPattern === null) {\n      re = pathToRegexp('*', keys);\n\n      toPath = function toPath() {\n        return '';\n      };\n\n      matchExact = true;\n      priority = -1;\n    }\n\n    if (!matchExact) {\n      var wildcardRe = pathToRegexp(pathPattern + \"/*\", keys);\n      re = new RegExp(\"(?:\" + re.source + \")|(?:\" + wildcardRe.source + \")\");\n    }\n\n    pathsByRouteNames[routeName] = {\n      re: re,\n      keys: keys,\n      toPath: toPath,\n      priority: priority,\n      pathPattern: pathPattern\n    };\n  });\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort(function (a, b) {\n    return b[1].priority - a[1].priority;\n  });\n\n  var getActionForPathAndParams = function getActionForPathAndParams(pathToResolve) {\n    var inputParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!pathToResolve) {\n      return NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: _objectSpread({}, inputParams, initialRouteParams)\n      });\n    }\n\n    var matchedRouteName;\n    var pathMatch;\n    var pathMatchKeys;\n\n    for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n      var _ref3;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref3 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref3 = _i.value;\n      }\n\n      var _ref4 = _ref3;\n\n      var _ref2 = _slicedToArray(_ref4, 2);\n\n      var _routeName = _ref2[0];\n      var _path = _ref2[1];\n      var re = _path.re,\n          keys = _path.keys;\n      pathMatch = re.exec(pathToResolve);\n\n      if (pathMatch && pathMatch.length) {\n        pathMatchKeys = keys;\n        matchedRouteName = _routeName;\n        break;\n      }\n    }\n\n    if (!matchedRouteName) {\n      return null;\n    }\n\n    var nestedAction;\n\n    if (childRouters[matchedRouteName]) {\n      nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(pathMatch.slice(pathMatchKeys.length).join('/'), inputParams);\n\n      if (!nestedAction) {\n        return null;\n      }\n    }\n\n    var params = pathMatch.slice(1).reduce(function (paramsOut, matchResult, i) {\n      var key = pathMatchKeys[i];\n\n      if (!key || key.asterisk) {\n        return paramsOut;\n      }\n\n      var paramName = key.name;\n      var decodedMatchResult;\n\n      try {\n        decodedMatchResult = decodeURIComponent(matchResult);\n      } catch (e) {}\n\n      paramsOut[paramName] = decodedMatchResult || matchResult;\n      return paramsOut;\n    }, _objectSpread({}, inputParams));\n    return NavigationActions.navigate(_objectSpread({\n      routeName: matchedRouteName\n    }, params ? {\n      params: params\n    } : {}, nestedAction ? {\n      action: nestedAction\n    } : {}));\n  };\n\n  var getPathAndParamsForRoute = function getPathAndParamsForRoute(route) {\n    var routeName = route.routeName,\n        params = route.params;\n    var childRouter = childRouters[routeName];\n    var subPath = pathsByRouteNames[routeName].toPath(params);\n\n    if (childRouter) {\n      var child = childRouter.getPathAndParamsForState(route);\n      return {\n        path: subPath ? subPath + \"/\" + child.path : child.path,\n        params: child.params ? _objectSpread({}, params, child.params) : params\n      };\n    }\n\n    return {\n      path: subPath,\n      params: params\n    };\n  };\n\n  return {\n    getActionForPathAndParams: getActionForPathAndParams,\n    getPathAndParamsForRoute: getPathAndParamsForRoute\n  };\n};","map":{"version":3,"sources":["/Users/edisonalba/Desktop/Proyect-University/App/node_modules/react-navigation/src/routers/pathUtils.js"],"names":["pathToRegexp","NavigationActions","queryString","require","isEmpty","obj","key","urlToPathAndParams","url","uriPrefix","searchMatch","match","params","parse","urlWithoutSearch","delimiter","path","split","undefined","length","slice","createPathParser","childRouters","routeConfigs","pathConfigs","initialRouteName","initialRouteParams","pathsByRouteNames","paths","Object","keys","forEach","routeName","pathPattern","matchExact","re","toPath","priority","compile","wildcardRe","RegExp","source","entries","sort","a","b","getActionForPathAndParams","pathToResolve","inputParams","navigate","matchedRouteName","pathMatch","pathMatchKeys","exec","nestedAction","join","reduce","paramsOut","matchResult","i","asterisk","paramName","name","decodedMatchResult","decodeURIComponent","e","action","getPathAndParamsForRoute","route","childRouter","subPath","child","getPathAndParamsForState"],"mappings":"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","sourcesContent":["import pathToRegexp from 'path-to-regexp';\nimport NavigationActions from '../NavigationActions';\nconst queryString = require('query-string');\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n  for (let key in obj) {\n    return false;\n  }\n  return true;\n}\n\nexport const urlToPathAndParams = (url, uriPrefix) => {\n  const searchMatch = url.match(/^(.*)\\?(.*)$/);\n  const params = searchMatch ? queryString.parse(searchMatch[2]) : {};\n  const urlWithoutSearch = searchMatch ? searchMatch[1] : url;\n  const delimiter = uriPrefix || '://';\n  let path = urlWithoutSearch.split(delimiter)[1];\n  if (path === undefined) {\n    path = urlWithoutSearch;\n  }\n  if (path === '/') {\n    path = '';\n  }\n  if (path[path.length - 1] === '/') {\n    path = path.slice(0, -1);\n  }\n  return {\n    path,\n    params,\n  };\n};\n\nexport const createPathParser = (\n  childRouters,\n  routeConfigs,\n  pathConfigs = {},\n  initialRouteName,\n  initialRouteParams\n) => {\n  const pathsByRouteNames = {};\n  let paths = [];\n\n  // Build paths for each route\n  Object.keys(childRouters).forEach(routeName => {\n    let pathPattern = pathConfigs[routeName] || routeConfigs[routeName].path;\n    let matchExact = !!pathPattern && !childRouters[routeName];\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n    const keys = [];\n    let re, toPath, priority;\n    if (typeof pathPattern === 'string') {\n      // pathPattern may be either a string or a regexp object according to path-to-regexp docs.\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else if (pathPattern === null) {\n      // for wildcard match\n      re = pathToRegexp('*', keys);\n      toPath = () => '';\n      matchExact = true;\n      priority = -1;\n    }\n    if (!matchExact) {\n      const wildcardRe = pathToRegexp(`${pathPattern}/*`, keys);\n      re = new RegExp(`(?:${re.source})|(?:${wildcardRe.source})`);\n    }\n    pathsByRouteNames[routeName] = { re, keys, toPath, priority, pathPattern };\n  });\n\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort((a, b) => b[1].priority - a[1].priority);\n\n  const getActionForPathAndParams = (pathToResolve, inputParams = {}) => {\n    // If the path is empty (null or empty string)\n    // just return the initial route action\n    if (!pathToResolve) {\n      return NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: { ...inputParams, ...initialRouteParams },\n      });\n    }\n\n    // Attempt to match `pathToResolve` with a route in this router's\n    // routeConfigs\n    let matchedRouteName;\n    let pathMatch;\n    let pathMatchKeys;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [routeName, path] of paths) {\n      const { re, keys } = path;\n      pathMatch = re.exec(pathToResolve);\n      if (pathMatch && pathMatch.length) {\n        pathMatchKeys = keys;\n        matchedRouteName = routeName;\n        break;\n      }\n    }\n\n    // We didn't match -- return null to signify no action available\n    if (!matchedRouteName) {\n      return null;\n    }\n\n    // Determine nested actions:\n    // If our matched route for this router is a child router,\n    // get the action for the path AFTER the matched path for this\n    // router\n    let nestedAction;\n    if (childRouters[matchedRouteName]) {\n      nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(\n        pathMatch.slice(pathMatchKeys.length).join('/'),\n        inputParams\n      );\n      if (!nestedAction) {\n        return null;\n      }\n    }\n\n    const params = pathMatch.slice(1).reduce(\n      // iterate over matched path params\n      (paramsOut, matchResult, i) => {\n        const key = pathMatchKeys[i];\n        if (!key || key.asterisk) {\n          return paramsOut;\n        }\n        const paramName = key.name;\n\n        let decodedMatchResult;\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {\n          // ignore `URIError: malformed URI`\n        }\n\n        paramsOut[paramName] = decodedMatchResult || matchResult;\n        return paramsOut;\n      },\n      {\n        // start with the input(query string) params, which will get overridden by path params\n        ...inputParams,\n      }\n    );\n\n    return NavigationActions.navigate({\n      routeName: matchedRouteName,\n      ...(params ? { params } : {}),\n      ...(nestedAction ? { action: nestedAction } : {}),\n    });\n  };\n  const getPathAndParamsForRoute = route => {\n    const { routeName, params } = route;\n    const childRouter = childRouters[routeName];\n    const subPath = pathsByRouteNames[routeName].toPath(params);\n    if (childRouter) {\n      // If it has a router it's a navigator.\n      // If it doesn't have router it's an ordinary React component.\n      const child = childRouter.getPathAndParamsForState(route);\n      return {\n        path: subPath ? `${subPath}/${child.path}` : child.path,\n        params: child.params ? { ...params, ...child.params } : params,\n      };\n    }\n    return {\n      path: subPath,\n      params,\n    };\n  };\n  return { getActionForPathAndParams, getPathAndParamsForRoute };\n};\n"]},"metadata":{},"sourceType":"module"}